#Stein-Chen statistic for Poi-null.

#First, computing asymptotic power curves of Section 3 by using Theorem 1.
#Second, simulation results of Section 5 and Supplement S1.



#Functions for ZIP distribution with
#default parametrization (lambda,omega):

#Probability mass function in x:
dzip <- function(x, lambda, omega=0) omega*(x==0) + (1-omega)*dpois(x, lambda)

#Cumulative distribution function in x:
pzip <- function(x, lambda, omega=0) omega*(x>=0) + (1-omega)*ppois(x, lambda)

#n i.i.d. random numbers:
rzip <- function(n, lambda, omega=0) rbinom(n, 1, 1-omega)*rpois(n, lambda)

#Quantile function in quantile level ql:
qzip <- function(ql, lambda, omega=0){
	up <- qpois(ql, lambda) #ZIP quantiles not later than Poi quantiles
	cdf <- pzib(0:up, lambda, omega)
	min((0:up)[cdf>=ql])
}
qzip <- Vectorize(qzip)
#These functions are used for the alternative hypothesis.



#Functions for Good distribution

#For Good distribution, the polylogarithm needs to be approximated,
#where summation truncated if summands get smaller than tol:
polylog <- function(z, delta, tol=1e-10){
	value <- 0
	
	if(abs(z)<1){
		x <- 1
		while(z^x/x^delta > tol){
			value <- value+z^x/x^delta
			x <- x+1
		}
	}
value
}

#Good distribution with parametrization (bet, delta):

#Probability mass function in x:
dgood <- function(x, bet, delta) exp(bet*(x+1) - delta*log(x+1)) / polylog(exp(bet), delta)

#Cumulative distribution function in x:
pgood <- function(x, bet, delta) sum(dgood(0:x, bet, delta))
pgood <- Vectorize(pgood)

#n i.i.d. Good random counts generated by using
#sample(0:upper, n, replace=TRUE, prob=pmf):
rgood <- function(n, bet, delta, upper=50){
	pmf <- dgood(0:upper, bet, delta)
	sample(0:upper, n, replace=TRUE, prob=pmf)
}

#Later, we choose Good parametrization based on mean and dispersion ratio:

#Mean
mgood <- function(bet, delta){
	polylog(exp(bet), delta-1)/polylog(exp(bet), delta) -1
}

#Variance
vgood <- function(bet, delta){
	polylog(exp(bet), delta-2)/polylog(exp(bet), delta) - polylog(exp(bet), delta-1)^2/polylog(exp(bet), delta)^2
}

#Find parameter values for given mean and dispersion ratio via squared deviations:
goodSQ <- function(par, mom){ #par=c(bet,delta), mom=c(mean,Idisp)
	bet <- par[1]
	delta <- par[2]
	
	m <- mom[1]
	v <- mom[2]*m
	
	(mgood(bet, delta)-m)^2 + (vgood(bet, delta)-v)^2
}
#Later, these squared deviations are minimized,
#because theoretically, they should be zero.

#These functions are used for the alternative hypothesis.





#Now, Stein statistics and asymptotics from manuscript.

#Sample Stein-Chen statistic (3), data x, function f:
sTSC <- function(x, f){
	mean(x*f(x)) / mean(x) / mean(f(x+1))
}

#Approximate moment computation (10) of order "klvec" and function f, 
#where upper truncation limit M implicitly provided by length of pmf vector "dist":
mu.f <- function(klvec, dist, f){
	upper <- length(dist)-1
	x <- 0:upper
	
	k <- klvec[1]
	
	mom <- NA
	if(length(klvec)==1) mom <- sum(x^k * dist)
	if(length(klvec)>1){
		l <- klvec[-1]
		mom <- sum( apply(cbind(x^k, apply(outer(x, l, "+"), 2, f)), 1, prod) * dist )
	}
	mom
}
#mu.f(c(0,1), dpois(0:10, 0.994), function(x) exp(-x)) #0.1962575
#mu.f(c(2), dpois(0:10, 0.994), function(x) exp(-x)) #1.982035

#Population Stein-Chen statistic (4),
#for pmf vector "dist" and function f:
TSC <- function(dist, f){
	mu.f(c(1,0), dist, f) / mu.f(1, dist, f) / mu.f(c(0,1), dist, f)
}
#TSC(dpois(0:10, 0.994), function(x) exp(-x)) #1
#TSC(dnbinom(0:50, 10, 0.4), function(x) exp(-x)) #0.513345



#Asymptotics of test statistic according to Theorem 1:

#"Normalized" covariances, i.e., Cov/mu1/mu2,
#for pmf vector "dist" and function f:
nsig <- function(dist, f){
	
	#Some expressions occur repeatedly:
	mu <- mu.f(1, dist, f)
	mu10 <- mu.f(c(1,0), dist, f)
	mu01 <- mu.f(c(0,1), dist, f)

	sig11 <- mu.f(2, dist, f)/mu^2 - 1
	sig12 <- mu.f(c(2,0), dist, f)/mu/mu10 - 1
	sig13 <- mu.f(c(1,1), dist, f)/mu/mu01 - 1
	sig22 <- mu.f(c(2,0,0), dist, f)/mu10^2 - 1
	sig23 <- mu.f(c(1,0,1), dist, f)/mu10/mu01 - 1
	sig33 <- mu.f(c(0,1,1), dist, f)/mu01^2 - 1
	
	c(sig11, sig12, sig13, sig22, sig23, sig33)
}

#Asymptotic mean and SD with sample size n,
#for pmf vector "dist" and function f:
TSCmeansd <- function(n, dist, f){
	Tf <- TSC(dist, f)
	nsigs <- nsig(dist, f)
	
	muTf <- Tf + Tf/n * sum(nsigs * c(1,-1,1,0,-1,1))
	sigTf <- sqrt(Tf^2/n * sum(nsigs * c(1,-2,2,1,-2,1)))
	
	c(muTf, sigTf)
}
#TSCmeansd(156, dpois(0:10, 0.994), function(x) exp(-x)) #1.00602803 0.08339678
#TSCmeansd(156, dnbinom(0:50, 10, 0.4), function(x) exp(-x)) #0.8570471 0.3898816





#Testing H0: Poi with mean mu
#against H1: another dist

#Two-sided critical values for given level,
#with mean mu, sample size n, function f, and upper truncation:
crit.poi <- function(mu, n, f, upper=50, level=0.05){
	z2 <- qnorm(1-level/2)
	pmf <- dpois(0:upper, mu)
	
	musig <- TSCmeansd(n, pmf, f)
	musig[1] + c(-1,1) * z2 * musig[2]
}
#crit.poi(0.994, 156, function(x) exp(-x)) #0.8425732 1.1694827

#Exceedance probability for given interval "crit" under alternative (specified by pmf vector "dist"),
#with sample size n and function f,
#where crit might be computed using function "crit.poi":
apower <- function(n, dist, f, crit){
	musig <- TSCmeansd(n, dist, f)

	pnorm(crit[1], musig[1], musig[2]) + 1-pnorm(crit[2], musig[1], musig[2])
}
#apower(156, dnbinom(0:50, 10, 10/10.994), function(x) exp(-x), crit.poi(0.994, 156, function(x) exp(-x))) #0.1067408








###########################
#Power curves of Section 3:
###########################



#Power curves for overdispersion case, see Figure 1.

#Power with f(x)=|x-1|^a against NB alternative
#note that NB-dispersion index equals I=1+mu/nu,
#i.e., nu=mu/(I-1)

upper <- 50

mu <- 2
tabI <- c(1.1, 1.25, 1.5)
tabnu <- mu/(tabI-1)
no.I <- length(tabI)
n <- 100

tab.a <- seq(0.1,3,0.1)
no.a <- length(tab.a)

tab.crit <- array(NA, c(no.a, 2))
for(k in 1:no.a){
	a <- tab.a[k]
	f <- function(x) abs(x-1)^a
	tab.crit[k,] <- crit.poi(mu, n, f)
}

tab.power <- array(NA, c(no.a, no.I))
for(k in 1:no.a){
	a <- tab.a[k]
	f <- function(x) abs(x-1)^a
	crit <- tab.crit[k,]
	
for(l in 1:no.I){
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 1(a):
matplot(tab.a, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="a", ylab="Power", main=paste("H0: Poi; H1: NB; mu=", mu, ", n=", n, sep=""))
legend("topright",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8, bg=grey(1))
abline(h=0.05, lty=2)


#Find optimal a numerically:
for(l in 1:no.I){
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))

	f.optim <- function(a){
		f <- function(x) abs(x-1)^a
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	a.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], a.opt$par, -a.opt$value))
} #for I
#100   2.0000000   1.1000000   1.7193634   0.1437202
#100   2.0000000   1.2500000   1.0337769   0.4365804
#100   2.0000000   1.5000000   0.8167225   0.8226934




#Power with f(x)=|x-1|^a against ZIP alternative
#note that mu=(1-om)*lam and I=1+om*lam,
#i.e., lam=mu+I-1

upper <- 50

mu <- 2
tabI <- c(1.1, 1.25, 1.5)
tab.lam <- mu+tabI-1
tab.om <- 1-mu/tab.lam
no.I <- length(tabI)
n <- 100

tab.a <- seq(0.1,3,0.1)
no.a <- length(tab.a)

tab.power <- array(NA, c(no.a, no.I))
for(k in 1:no.a){
	a <- tab.a[k]
	f <- function(x) abs(x-1)^a
	crit <- crit.poi(mu, n, f)
	
for(l in 1:no.I){
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 1(b):
matplot(tab.a, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="a", ylab="Power", main=paste("H0: Poi; H1: ZIP; mu=", mu, ", n=", n, sep=""))
legend("topright",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8)
abline(h=0.05, lty=2)


#Find optimal a numerically:
for(l in 1:no.I){
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)

	f.optim <- function(a){
		f <- function(x) abs(x-1)^a
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	a.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], a.opt$par, -a.opt$value))
} #for I
#100   2.0000000   1.1000000   0.2410169   0.2113141
#100   2.0000000   1.2500000   0.2312942   0.6976349
#100   2.0000000   1.5000000   0.2172152   0.9782204




#Power with Box-Cox f(x)=(x^b-1)/b against NB alternative
#note that NB-dispersion index equals I=1+mu/nu,
#i.e., nu=mu/(I-1)

upper <- 50

mu <- 2
tabI <- c(1.1, 1.25, 1.5)
tabnu <- mu/(tabI-1)
no.I <- length(tabI)
n <- 100

tab.b <- seq(0.1,3,0.1)
no.b <- length(tab.b)

tab.power <- array(NA, c(no.b, no.I))
for(k in 1:no.b){
	b <- tab.b[k]
	f <- function(x) (x^b-1)/b
	crit <- crit.poi(mu, n, f)
	
for(l in 1:no.I){
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 1(c):
matplot(tab.b, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="b", ylab="Power", main=paste("H0: Poi; H1: NB; mu=", mu, ", n=", n, sep=""))
legend("topright",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8, bg=grey(1))
abline(h=0.05, lty=2)


#Find optimal b numerically:
for(l in 1:no.I){
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))

	f.optim <- function(b){
		f <- function(x) (x^b-1)/b
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	b.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], b.opt$par, -b.opt$value))
} #for I
#100   2.000000   1.100000   4.999900   0.164935
#100   2.0000000   1.2500000   1.1801354   0.4374394
#100   2.0000000   1.5000000   0.6398454   0.8231910



#Power with Box-Cox f(x)=(x^b-1)/b against ZIP alternative
#note that mu=(1-om)*lam and I=1+om*lam,
#i.e., lam=mu+I-1

upper <- 50

mu <- 2
tabI <- c(1.1, 1.25, 1.5)
tab.lam <- mu+tabI-1
tab.om <- 1-mu/tab.lam
no.I <- length(tabI)
n <- 100

tab.b <- seq(0.1,3,0.1)
no.b <- length(tab.b)

tab.power <- array(NA, c(no.b, no.I))
for(k in 1:no.b){
	b <- tab.b[k]
	f <- function(x) (x^b-1)/b
	crit <- crit.poi(mu, n, f)
	
for(l in 1:no.I){
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 1(d):
matplot(tab.b, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="b", ylab="Power", main=paste("H0: Poi; H1: ZIP; mu=", mu, ", n=", n, sep=""))
legend("topright",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8, bg=grey(1))
abline(h=0.05, lty=2)


#Find optimal b numerically:
for(l in 1:no.I){
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)

	f.optim <- function(b){
		f <- function(x) (x^b-1)/b
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	b.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], b.opt$par, -b.opt$value))
} #for I
#100   2.0000000   1.1000000   0.0001000   0.1811338
#100   2.0000000   1.2500000   0.0001000   0.6202016
#100   2.0000000   1.5000000   0.0001000   0.9597187




#Power with f(x)=u^x against NB alternative
#note that NB-dispersion index equals I=1+mu/nu,
#i.e., nu=mu/(I-1)

upper <- 50

mu <- 2
tabI <- c(1.1, 1.25, 1.5)
tabnu <- mu/(tabI-1)
no.I <- length(tabI)
n <- 100

tab.u <- seq(0.01,0.99,0.01)
no.u <- length(tab.u)

tab.power <- array(NA, c(no.u, no.I))
for(k in 1:no.u){
	u <- tab.u[k]
	f <- function(x) u^x
	crit <- crit.poi(mu, n, f)
	
for(l in 1:no.I){
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 1(e):
matplot(tab.u, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="u", ylab="Power", main=paste("H0: Poi; H1: NB; mu=", mu, ", n=", n, sep=""))
legend("topleft",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8)
abline(h=0.05, lty=2)


#Find optimal u numerically:
for(l in 1:no.I){
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))

	f.optim <- function(u){
		f <- function(x) u^x
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	u.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(0.9999), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], u.opt$par, -u.opt$value))
} #for I
#100   2.0000000   1.1000000   0.9999000   0.1406306
#100   2.0000000   1.2500000   0.9999000   0.4369378
#100   2.0000000   1.5000000   0.9330555   0.8166315




#Power with f(x)=u^x against ZIP alternative
#note that mu=(1-om)*lam and I=1+om*lam,
#i.e., lam=mu+I-1

upper <- 50

mu <- 2
tabI <- c(1.1, 1.25, 1.5)
tab.lam <- mu+tabI-1
tab.om <- 1-mu/tab.lam
no.I <- length(tabI)
n <- 100

tab.u <- seq(0.01,0.99,0.01)
no.u <- length(tab.u)

tab.power <- array(NA, c(no.u, no.I))
for(k in 1:no.u){
	u <- tab.u[k]
	f <- function(x) u^x
	crit <- crit.poi(mu, n, f)
	
for(l in 1:no.I){
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 1(f):
matplot(tab.u, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="u", ylab="Power", main=paste("H0: Poi; H1: ZIP; mu=", mu, ", n=", n, sep=""))
legend("topright",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8, bg=grey(1))
abline(h=0.05, lty=2)


#Find optimal u numerically:
for(l in 1:no.I){
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)

	f.optim <- function(u){
		f <- function(x) u^x
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	u.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(0.9999), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], u.opt$par, -u.opt$value))
} #for I
#100   2.0000000   1.1000000   0.5856217   0.1546737
#100   2.0000000   1.2500000   0.4803183   0.5975422
#100   2.0000000   1.5000000   0.3208073   0.9927516




#Power curves for underdispersion case, see Figure 2.

#Power with f(x)=|x-1|^a against Good alternative,
#where parameters (bet,delta) are chosen numerically 
#such that target mean and dispersion ensured.

upper <- 50

mu <- 4
tabI <- c(0.9, 0.8, 0.7)
no.I <- length(tabI)
n <- 100

tab.a <- seq(0.1,3,0.1)
no.a <- length(tab.a)

tab.crit <- array(NA, c(no.a, 2))
for(k in 1:no.a){
	a <- tab.a[k]
	f <- function(x) abs(x-1)^a
	tab.crit[k,] <- crit.poi(mu, n, f)
}

tab.power <- array(NA, c(no.a, no.I))
for(k in 1:no.a){
	a <- tab.a[k]
	f <- function(x) abs(x-1)^a
	crit <- tab.crit[k,]
	
for(l in 1:no.I){
	good.ab <- suppressWarnings(optim(c(-2, -4), goodSQ, method="L-BFGS-B", lower=c(-5,-10), upper=c(-1,0), control=list(ndeps=c(1e-4,1e-4)), mom=c(mu, tabI[l])))$par
	pmf <- dgood(0:upper, good.ab[1], good.ab[2])
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 2(a):
matplot(tab.a, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="a", ylab="Power", main=paste("H0: Poi; H1: Good; mu=", mu, ", n=", n, sep=""))
legend("topright",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8, bg=grey(1))
abline(h=0.05, lty=2)


#Find optimal a numerically:
for(l in 1:no.I){
	good.ab <- suppressWarnings(optim(c(-2, -4), goodSQ, method="L-BFGS-B", lower=c(-5,-10), upper=c(-1,0), control=list(ndeps=c(1e-4,1e-4)), mom=c(mu, tabI[l])))$par
	pmf <- dgood(0:upper, good.ab[1], good.ab[2])

	f.optim <- function(a){
		f <- function(x) abs(x-1)^a
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	a.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], a.opt$par, -a.opt$value))
} #for I
#100   4.0000000   0.9000000   0.4784359   0.1384212
#100   4.0000000   0.8000000   0.4995930   0.3443914
#100   4.0000000   0.7000000   0.5123222   0.6821480




#Power with f(x)=1/(x+1)^d against Good alternative,
#where parameters (bet,delta) are chosen numerically 
#such that target mean and dispersion ensured.

upper <- 50

mu <- 4
tabI <- c(0.9, 0.8, 0.7)
no.I <- length(tabI)
n <- 100

tab.d <- seq(0.01,3,0.01)
no.d <- length(tab.d)

tab.crit <- array(NA, c(no.d, 2))
for(k in 1:no.d){
	d <- tab.d[k]
	f <- function(x) 1/(x+1)^d
	tab.crit[k,] <- crit.poi(mu, n, f)
}

tab.power <- array(NA, c(no.d, no.I))
for(k in 1:no.d){
	d <- tab.d[k]
	f <- function(x) 1/(x+1)^d
	crit <- tab.crit[k,]
	
for(l in 1:no.I){
	good.ab <- suppressWarnings(optim(c(-2, -4), goodSQ, method="L-BFGS-B", lower=c(-5,-10), upper=c(-1,0), control=list(ndeps=c(1e-4,1e-4)), mom=c(mu, tabI[l])))$par
	pmf <- dgood(0:upper, good.ab[1], good.ab[2])
	tab.power[k,l] <- apower(n, pmf, f, crit)
}}

cols <- grey(c(0,0.3,0.6))

#Figure 2(b):
matplot(tab.d, tab.power, type="l", lwd=2, ylim=c(0,1), col=cols, lty=1, xlab="d", ylab="Power", main=paste("H0: Poi; H1: Good; mu=", mu, ", n=", n, sep=""))
legend("topright",legend=tabI, title=expression(I[Poi]*"="), lwd=2, col=cols, lty=1, cex=0.8, bg=grey(1))
abline(h=0.05, lty=2)


#Find optimal d numerically:
for(l in 1:no.I){
	good.ab <- suppressWarnings(optim(c(-2, -4), goodSQ, method="L-BFGS-B", lower=c(-5,-10), upper=c(-1,0), control=list(ndeps=c(1e-4,1e-4)), mom=c(mu, tabI[l])))$par
	pmf <- dgood(0:upper, good.ab[1], good.ab[2])

	f.optim <- function(d){
		f <- function(x) 1/(x+1)^d
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	d.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(3), control=list(ndeps=c(1e-4)))
	print(c(n,mu,tabI[l], d.opt$par, -d.opt$value))
} #for I
#100   4.0000000   0.9000000   3.0000000   0.2467104
#100   4.0000000   0.8000000   1.3912340   0.4723913
#100   4.0000000   0.7000000   1.1872743   0.8064985









###########################
#Simulations for Section 5:
###########################

#NB alternative with f(x)=|x-1|^a, see Table 1:

set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(1.1, 1.25, 1.5, 2)
no.I <- length(tabI)
tabnu <- mu/(tabI-1)
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	Id <- tabI[l]
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(a){
		f <- function(x) abs(x-1)^a
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	a.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	apow <- -a.opt$value
	a.opt <- a.opt$par
	opt.des[l,k,1] <- a.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) abs(x-1)^a.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rnbinom(n, nu, nu/(nu+mu))
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results

 # [1,]    2 1.10   50 4.9999000 0.1617505  456   1247
 # [2,]    2 1.10  100 1.7193634 0.1437202 4413  12314
 # [3,]    2 1.10  250 1.1260295 0.2296826 4790  21810
 # [4,]    2 1.25   50 1.2865789 0.2968208 4600  24672
 # [5,]    2 1.25  100 1.0337769 0.4365804 4911  40180
 # [6,]    2 1.25  250 0.9272283 0.7321826 5015  72612
 # [7,]    2 1.50   50 0.8902972 0.6125953 5000  57960
 # [8,]    2 1.50  100 0.8167225 0.8226934 4942  82414
 # [9,]    2 1.50  250 0.7628869 0.9861976 5177  99176
# [10,]    2 2.00   50 0.6521596 0.8978719 5264  92040
# [11,]    2 2.00  100 0.6187068 0.9864418 5132  99509
# [12,]    2 2.00  250 0.5890064 0.9999768 5052 100000

 # [1,]    4 1.10   50 4.9999000 0.1261465 1260   2737
 # [2,]    4 1.10  100 1.4502447 0.1382852 4788  12978
 # [3,]    4 1.10  250 1.0961717 0.2264286 4858  21722
 # [4,]    4 1.25   50 1.1906600 0.2897198 4614  25529
 # [5,]    4 1.25  100 0.9973697 0.4356361 4847  40905
 # [6,]    4 1.25  250 0.9137634 0.7386603 5049  73142
 # [7,]    4 1.50   50 0.8451864 0.6212850 4814  59480
 # [8,]    4 1.50  100 0.8033865 0.8353214 4901  83777
 # [9,]    4 1.50  250 0.7747196 0.9891988 5004  99324
# [10,]    4 2.00   50 0.6571536 0.9140085 4829  93482
# [11,]    4 2.00  100 0.6500828 0.9905665 4779  99664
# [12,]    4 2.00  250 0.6423011 0.9999910 4860 100000





#ZIP alternative with f(x)=|x-1|^a, see Table 2:

set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(1.1, 1.25, 1.5, 2)
no.I <- length(tabI)
tab.lam <- mu+tabI-1
tab.om <- 1-mu/tab.lam
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	Id <- tabI[l]
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(a){
		f <- function(x) abs(x-1)^a
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	a.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	apow <- -a.opt$value
	a.opt <- a.opt$par
	opt.des[l,k,1] <- a.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) abs(x-1)^a.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rzip(n, lam, om)
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2 1.10   50 0.2446627 0.1466894 5705  14591
 # [2,]    2 1.10  100 0.2410169 0.2113141 5388  20419
 # [3,]    2 1.10  250 0.2376410 0.3927448 5162  37996
 # [4,]    2 1.25   50 0.2337779 0.4770593 5599  43820
 # [5,]    2 1.25  100 0.2312942 0.6976349 5388  67931
 # [6,]    2 1.25  250 0.2281356 0.9529368 5048  96041
 # [7,]    2 1.50   50 0.2198919 0.8651081 5693  86721
 # [8,]    2 1.50  100 0.2172152 0.9782204 5312  98832
 # [9,]    2 1.50  250 0.2133844 0.9999413 5195 100000
# [10,]    2 2.00   50 0.1959364 0.9900217 5694  99876
# [11,]    2 2.00  100 0.1924716 0.9998188 5358 100000
# [12,]    2 2.00  250 0.9999904 0.9999991 4905 100000

 # [1,]    4 1.10   50 0.1179267 0.3318354 5269  29620
 # [2,]    4 1.10  100 0.1171376 0.4491881 4531  40662
 # [3,]    4 1.10  250 0.1161425 0.7010403 4885  68369
 # [4,]    4 1.25   50 0.1151651 0.7189411 5287  69003
 # [5,]    4 1.25  100 0.1139834 0.8782038 4497  88275
 # [6,]    4 1.25  250 0.1124182 0.9909771 4787  99613
 # [7,]    4 1.50   50 0.1113072 0.9325397 5267  94979
 # [8,]    4 1.50  100 0.1094115 0.9903878 4545  99743
 # [9,]    4 1.50  250 0.1068345 0.9999752 4706 100000
# [10,]    4 2.00   50 0.1055584 0.9922773 5195  99917
# [11,]    4 2.00  100 0.1022596 0.9997965 4472 100000
# [12,]    4 2.00  250 0.9999577 0.9999953 4854 100000





#ZIP alternative with f(x)=u^x, see Table 3:

set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(1.1, 1.25, 1.5, 2)
no.I <- length(tabI)
tab.lam <- mu+tabI-1
tab.om <- 1-mu/tab.lam
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	Id <- tabI[l]
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(u){
		f <- function(x) u^x
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	u.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(0.9999), control=list(ndeps=c(1e-4)))
	apow <- -u.opt$value
	u.opt <- u.opt$par
	opt.des[l,k,1] <- u.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) u.opt^x
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rzip(n, lam, om)
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2 1.10   50 0.7104067 0.1044773 4812  10498
 # [2,]    2 1.10  100 0.5856217 0.1546737 5024  15585
 # [3,]    2 1.10  250 0.4645754 0.3197718 5091  32598
 # [4,]    2 1.25   50 0.6021724 0.3386218 4964  34293
 # [5,]    2 1.25  100 0.4803183 0.5975422 5056  60741
 # [6,]    2 1.25  250 0.3294196 0.9556228 5117  94836
 # [7,]    2 1.50   50 0.4600201 0.8272551 5342  82203
 # [8,]    2 1.50  100 0.3208073 0.9927516 5439  98372
 # [9,]    2 1.50  250 0.2535488 1.0000000 5241 100000
# [10,]    2 2.00   50 0.3020811 0.9999863 5846  99873
# [11,]    2 2.00  100 0.5490055 1.0000000 4902 100000
# [12,]    2 2.00  250 0.9998993 1.0000000 4857 100000

 # [1,]    4 1.10   50 0.5705571 0.1729977 4591  17882
 # [2,]    4 1.10  100 0.4992224 0.2769540 4820  29395
 # [3,]    4 1.10  250 0.4006673 0.5754064 5036  59352
 # [4,]    4 1.25   50 0.5192182 0.5197197 4545  55162
 # [5,]    4 1.25  100 0.3997381 0.8325658 4915  82673
 # [6,]    4 1.25  250 0.2596039 0.9994418 5429  99293
 # [7,]    4 1.50   50 0.3926924 0.9623563 4263  92272
 # [8,]    4 1.50  100 0.2980231 0.9999861 5729  99615
 # [9,]    4 1.50  250 0.5535780 1.0000000 4822 100000
# [10,]    4 2.00   50 0.4527591 1.0000000 4333  99930
# [11,]    4 2.00  100 0.6647123 1.0000000 4720 100000
# [12,]    4 2.00  250 0.9998864 0.9999997 4829 100000






#Good alternative with f(x)=1/(x+1)^d, see Table 4:
set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(0.9, 0.8, 0.7, 0.6)
no.I <- length(tabI)
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	good.ab <- suppressWarnings(optim(c(-2, -4), goodSQ, method="L-BFGS-B", lower=c(-5,-10), upper=c(-1,0), control=list(ndeps=c(1e-4,1e-4)), mom=c(mu, tabI[l])))$par
	pmf <- dgood(0:upper, good.ab[1], good.ab[2])

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(d){
		f <- function(x) 1/(x+1)^d
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	d.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(3), control=list(ndeps=c(1e-4)))
	apow <- -d.opt$value
	d.opt <- d.opt$par
	opt.des[l,k,1] <- d.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) 1/(x+1)^d.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rgood(n, good.ab[1], good.ab[2])
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2  0.9   50 3.000000 0.2087391 5618 20731
 # [2,]    2  0.9  100 3.000000 0.3284279 5320 31904
 # [3,]    2  0.9  250 3.000000 0.6193181 5065 61110
 # [4,]    2  0.8   50 3.000000 0.3906332 5504 37436
 # [5,]    2  0.8  100 3.000000 0.6151299 5297 59916
 # [6,]    2  0.8  250 2.527745 0.9251809 5085 92685
 # [7,]    2  0.7   50 3.000000 0.6208654 5505 61006
 # [8,]    2  0.7  100 2.978945 0.8663257 5263 86562
 # [9,]    2  0.7  250 1.434274 0.9984531 5070 99810
# [10,]    2  0.6   50 3.000000 0.8369463 5596 83487
# [11,]    2  0.6  100 1.483311 0.9880124 5086 98515
# [12,]    2  0.6  250 1.000000 0.9999998 4984 99999

 # [1,]    4  0.9   50 0.7688055 0.0879562 4506   7764
 # [2,]    4  0.9  100 3.0000000 0.2467104 3572  24674
 # [3,]    4  0.9  250 3.0000000 0.7047934 4928  72103
 # [4,]    4  0.8   50 0.6583906 0.1815212 4519  17816
 # [5,]    4  0.8  100 1.3912340 0.4723913 4570  49186
 # [6,]    4  0.8  250 1.9756744 0.9612166 4692  95413
 # [7,]    4  0.7   50 0.6052440 0.3637769 4648  38055
 # [8,]    4  0.7  100 1.1872743 0.8064985 4633  81208
 # [9,]    4  0.7  250 1.7977673 0.9997313 4816  99894
# [10,]    4  0.6   50 0.5684558 0.6484491 4623  66797
# [11,]    4  0.6  100 1.0846280 0.9817051 4776  97690
# [12,]    4  0.6  250 1.0000000 1.0000000 4902 100000









###############################
#Simulations for Supplement S1:
###############################

#NB alternative with f(x)=(x^b-1)/b, see Table S1:

set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(1.1, 1.25, 1.5, 2)
no.I <- length(tabI)
tabnu <- mu/(tabI-1)
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	Id <- tabI[l]
	nu <- tabnu[l]
	pmf <- dnbinom(0:upper, nu, nu/(nu+mu))

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(b){
		f <- function(x) (x^b-1)/b
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	b.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	apow <- -b.opt$value
	b.opt <- b.opt$par
	opt.des[l,k,1] <- b.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) (x^b.opt-1)/b.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rnbinom(n, nu, nu/(nu+mu))
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2 1.10   50 4.99990000 0.1595379 1029   2460
 # [2,]    2 1.10  100 4.99990000 0.1649350 1693   4331
 # [3,]    2 1.10  250 1.35923295 0.2308790 4716  21731
 # [4,]    2 1.25   50 4.99990000 0.3607737 1073   5943
 # [5,]    2 1.25  100 1.18013537 0.4374394 4852  39899
 # [6,]    2 1.25  250 0.88411654 0.7319552 5021  72588
 # [7,]    2 1.50   50 0.85506362 0.6117357 4955  57900
 # [8,]    2 1.50  100 0.63984542 0.8231910 4983  82428
 # [9,]    2 1.50  250 0.49145679 0.9868142 5167  99168
# [10,]    2 2.00   50 0.25383087 0.9020688 5342  91988
# [11,]    2 2.00  100 0.16819244 0.9881960 5172  99512
# [12,]    2 2.00  250 0.09278321 0.9999859 5052 100000

 # [1,]    4 1.10   50 4.9999000 0.1273358 1701   3652
 # [2,]    4 1.10  100 1.8676619 0.1396110 4653  12737
 # [3,]    4 1.10  250 1.2163161 0.2268266 4868  21675
 # [4,]    4 1.25   50 1.4785479 0.2915151 4442  25069
 # [5,]    4 1.25  100 1.0791896 0.4358050 4839  40832
 # [6,]    4 1.25  250 0.8910485 0.7384937 5048  73129
 # [7,]    4 1.50   50 0.8224745 0.6204984 4827  59359
 # [8,]    4 1.50  100 0.6966738 0.8354563 4907  83723
 # [9,]    4 1.50  250 0.6110033 0.9894640 5027  99337
# [10,]    4 2.00   50 0.3982715 0.9161330 4895  93448
# [11,]    4 2.00  100 0.3622309 0.9913733 4803  99664
# [12,]    4 2.00  250 0.3300921 0.9999935 4917 100000





#ZIP alternative with f(x)=(x^b-1)/b, see Table S2:

set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(1.1, 1.25, 1.5, 2)
no.I <- length(tabI)
tab.lam <- mu+tabI-1
tab.om <- 1-mu/tab.lam
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	Id <- tabI[l]
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(b){
		f <- function(x) (x^b-1)/b
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	b.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	apow <- -b.opt$value
	b.opt <- b.opt$par
	opt.des[l,k,1] <- b.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) (x^b.opt-1)/b.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rzip(n, lam, om)
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2 1.10   50 0.0001000 0.1291740 5368  12826
 # [2,]    2 1.10  100 0.0001000 0.1811338 5233  17621
 # [3,]    2 1.10  250 0.0001000 0.3311144 5071  32083
 # [4,]    2 1.25   50 0.0001000 0.4126765 5443  37508
 # [5,]    2 1.25  100 0.0001000 0.6202016 5183  59637
 # [6,]    2 1.25  250 0.0001000 0.9140750 5040  91997
 # [7,]    2 1.50   50 0.0001000 0.8137733 5383  80410
 # [8,]    2 1.50  100 0.0001000 0.9597187 5291  97130
 # [9,]    2 1.50  250 0.0001000 0.9997307 5101  99998
# [10,]    2 2.00   50 0.0001000 0.9832355 5430  99644
# [11,]    2 2.00  100 0.0001000 0.9995374 5028 100000
# [12,]    2 2.00  250 0.9999948 0.9999991 4905 100000

 # [1,]    4 1.10   50 0.0001000 0.1986937 4916  18272
 # [2,]    4 1.10  100 0.0001000 0.2721393 5022  25581
 # [3,]    4 1.10  250 0.0001000 0.4656212 4968  44996
 # [4,]    4 1.25   50 0.0001000 0.5399853 4865  49476
 # [5,]    4 1.25  100 0.0001000 0.7314130 4914  71639
 # [6,]    4 1.25  250 0.0001000 0.9523624 4966  95991
 # [7,]    4 1.50   50 0.0001000 0.8575824 4967  85855
 # [8,]    4 1.50  100 0.0001000 0.9684947 5085  97995
 # [9,]    4 1.50  250 0.0001000 0.9997196 4982  99999
# [10,]    4 2.00   50 0.0001000 0.9822989 4974  99531
# [11,]    4 2.00  100 0.0001000 0.9992737 4819 100000
# [12,]    4 2.00  250 0.9999734 0.9999953 4854 100000





#ZIP alternative with f(x)=1/(x+1)^d, see Table S3:
set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(1.1, 1.25, 1.5, 2)
no.I <- length(tabI)
tab.lam <- mu+tabI-1
tab.om <- 1-mu/tab.lam
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	Id <- tabI[l]
	lam <- tab.lam[l]
	om <- tab.om[l]
	pmf <- dzip(0:upper, lam, om)

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(d){
		f <- function(x) 1/(x+1)^d
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	d.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(3), control=list(ndeps=c(1e-4)))
	apow <- -d.opt$value
	d.opt <- d.opt$par
	opt.des[l,k,1] <- d.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) 1/(x+1)^d.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rzip(n, lam, om)
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2 1.10   50 0.5210492 0.1123740 4830  11228
 # [2,]    2 1.10  100 0.9762928 0.1659320 4948  16557
 # [3,]    2 1.10  250 1.5456024 0.3352075 5006  33721
 # [4,]    2 1.25   50 0.9020089 0.3667475 4896  36344
 # [5,]    2 1.25  100 1.4946394 0.6209944 4979  62482
 # [6,]    2 1.25  250 2.5412276 0.9573676 5044  95182
 # [7,]    2 1.50   50 1.7183318 0.8405887 5064  83535
 # [8,]    2 1.50  100 2.7812545 0.9928534 5291  98480
 # [9,]    2 1.50  250 1.0000192 0.9999950 5005  99999
# [10,]    2 2.00   50 3.0000000 0.9999848 5599  99882
# [11,]    2 2.00  100 1.0000005 0.9999999 4766 100000
# [12,]    2 2.00  250 1.0000000 1.0000000 4935 100000

 # [1,]    4 1.10   50 1.488890 0.2158179 3947  21121
 # [2,]    4 1.10  100 1.802064 0.3300160 4307  33467
 # [3,]    4 1.10  250 2.331868 0.6245349 4802  63147
 # [4,]    4 1.25   50 1.720067 0.5905017 3601  60283
 # [5,]    4 1.25  100 2.490986 0.8612432 3908  85239
 # [6,]    4 1.25  250 3.000000 0.9991525 4716  99507
 # [7,]    4 1.50   50 2.736759 0.9699121 2249  93368
 # [8,]    4 1.50  100 3.000000 0.9999777 3540  99715
 # [9,]    4 1.50  250 1.000011 0.9999984 4829 100000
# [10,]    4 2.00   50 2.447458 1.0000000 2646  99931
# [11,]    4 2.00  100 1.000001 0.9999999 4609 100000
# [12,]    4 2.00  250 1.000000 1.0000000 4820 100000






#Good alternative with f(x)=|x-1|^a, see Table S4:

set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(0.9, 0.8, 0.7, 0.6)
no.I <- length(tabI)
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	good.ab <- suppressWarnings(optim(c(-2, -4), goodSQ, method="L-BFGS-B", lower=c(-5,-10), upper=c(-1,0), control=list(ndeps=c(1e-4,1e-4)), mom=c(mu, tabI[l])))$par
	pmf <- dgood(0:upper, good.ab[1], good.ab[2])

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(a){
		f <- function(x) abs(x-1)^a
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	a.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	apow <- -a.opt$value
	a.opt <- a.opt$par
	opt.des[l,k,1] <- a.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) abs(x-1)^a.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rgood(n, good.ab[1], good.ab[2])
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2  0.9   50 0.2253912 0.1125941 5771 11106
 # [2,]    2  0.9  100 0.2068794 0.2083702 5317 21212
 # [3,]    2  0.9  250 0.1966878 0.4980103 5148 50654
 # [4,]    2  0.8   50 0.3631486 0.2144255 5335 21314
 # [5,]    2  0.8  100 0.3496658 0.4480733 5295 45499
 # [6,]    2  0.8  250 0.3399351 0.8824841 5099 88195
 # [7,]    2  0.7   50 0.4367826 0.4021112 5552 41149
 # [8,]    2  0.7  100 0.4301725 0.7738772 5182 77732
 # [9,]    2  0.7  250 0.4242924 0.9969290 5148 99571
# [10,]    2  0.6   50 0.4938228 0.6705685 5389 67814
# [11,]    2  0.6  100 0.4916797 0.9700206 5240 96731
# [12,]    2  0.6  250 0.4886479 0.9999989 5076 99999

 # [1,]    4  0.9   50 0.7452961 0.0785971 4807  6652
 # [2,]    4  0.9  100 0.4784359 0.1384212 4936 13328
 # [3,]    4  0.9  250 0.3178266 0.4090615 4930 42172
 # [4,]    4  0.8   50 0.6522832 0.1514809 4841 14260
 # [5,]    4  0.8  100 0.4995930 0.3443914 4891 35570
 # [6,]    4  0.8  250 0.3565772 0.8471027 4896 84941
 # [7,]    4  0.7   50 0.6482799 0.3006833 5011 31310
 # [8,]    4  0.7  100 0.5123222 0.6821480 4849 69329
 # [9,]    4  0.7  250 0.3737918 0.9957831 4994 99323
# [10,]    4  0.6   50 0.6508035 0.5566620 4842 57998
# [11,]    4  0.6  100 0.5255785 0.9464038 5069 94252
# [12,]    4  0.6  250 0.3891748 0.9999988 4932 99998





#Good alternative with f(x)=(x^b-1)/b, see Table S5:

set.seed(123)
reps <- 1e5

upper <- 50

mu <- 2 #4, switch between both choices of mu
tabI <- c(0.9, 0.8, 0.7, 0.6)
no.I <- length(tabI)
tabn <- c(50,100,250)
no.n <- length(tabn)



#Finite-sample performance of sizes:
reject <- array(0, c(no.I, no.n, 2))
opt.des <- array(0, c(no.I, no.n, 2))
for(l in 1:no.I){
	good.ab <- suppressWarnings(optim(c(-2, -4), goodSQ, method="L-BFGS-B", lower=c(-5,-10), upper=c(-1,0), control=list(ndeps=c(1e-4,1e-4)), mom=c(mu, tabI[l])))$par
	pmf <- dgood(0:upper, good.ab[1], good.ab[2])

for(k in 1:no.n){
	n <- tabn[k]
	f.optim <- function(b){
		f <- function(x) (x^b-1)/b
		-apower(n, pmf, f, crit.poi(mu, n, f))
	}
	
	b.opt <- optim(c(1), f.optim, method="L-BFGS-B", lower=c(0.0001), upper=c(4.9999), control=list(ndeps=c(1e-4)))
	apow <- -b.opt$value
	b.opt <- b.opt$par
	opt.des[l,k,1] <- b.opt
	opt.des[l,k,2] <- apow

	f.opt <- function(x) (x^b.opt-1)/b.opt
	crit.opt <- crit.poi(mu, n, f.opt)
	
	for(r in 1:reps){
		data0 <- rpois(n, mu)
		data1 <- rgood(n, good.ab[1], good.ab[2])
		
		T0 <- sTSC(data0, f.opt)
		T1 <- sTSC(data1, f.opt)
		
		if(T0<crit.opt[1] || T0>crit.opt[2]) reject[l,k,1] <- reject[l,k,1]+1
		if(T1<crit.opt[1] || T1>crit.opt[2]) reject[l,k,2] <- reject[l,k,2]+1
	} #for reps

	#print(c(mu,Id,n, opt.des[l,k,], reject[l,k,]))
}} #for n,I

results <- array(NA, c(no.I*no.n, 7))
i <- 0
for(l in 1:no.I){
for(k in 1:no.n){
	i <- i+1
	results[i,] <- c(mu, tabI[l], tabn[k], opt.des[l,k,], reject[l,k,])
}} #for n,I
results
 # [1,]    2  0.9   50 1e-04 0.1000602 5417  9678
 # [2,]    2  0.9  100 1e-04 0.1695796 5299 16968
 # [3,]    2  0.9  250 1e-04 0.3849482 5118 39209
 # [4,]    2  0.8   50 1e-04 0.2047256 5285 20347
 # [5,]    2  0.8  100 1e-04 0.4180357 5229 42729
 # [6,]    2  0.8  250 1e-04 0.8471709 4990 84782
 # [7,]    2  0.7   50 1e-04 0.4007124 5494 41033
 # [8,]    2  0.7  100 1e-04 0.7640262 5135 76789
 # [9,]    2  0.7  250 1e-04 0.9959622 5159 99490
# [10,]    2  0.6   50 1e-04 0.6796479 5401 68849
# [11,]    2  0.6  100 1e-04 0.9700628 5274 96708
# [12,]    2  0.6  250 1e-04 0.9999986 5083 99999

 # [1,]    4  0.9   50 0.1615559 0.08226015 4917  7372
 # [2,]    4  0.9  100 0.0001000 0.15902496 5024 15748
 # [3,]    4  0.9  250 0.0001000 0.41850100 4958 42695
 # [4,]    4  0.8   50 0.1175625 0.16545044 4890 15985
 # [5,]    4  0.8  100 0.0001000 0.39087627 4955 40139
 # [6,]    4  0.8  250 0.0001000 0.86680121 4964 86655
 # [7,]    4  0.7   50 0.1320017 0.32911540 5021 34015
 # [8,]    4  0.7  100 0.0001000 0.73411126 4973 74133
 # [9,]    4  0.7  250 0.0001000 0.99705274 5077 99553
# [10,]    4  0.6   50 0.1634712 0.59455004 5004 61185
# [11,]    4  0.6  100 0.0001000 0.96223223 5120 95857
# [12,]    4  0.6  250 0.0001000 0.99999937 5054 99999






